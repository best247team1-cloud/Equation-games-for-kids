<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math Kids Zone - Fun Learning</title>
    
    <!-- Tailwind CSS for Styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM (No Build Required) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel to compile React in Browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        /* Custom Animations */
        @keyframes fade-in { 0%{opacity:0} 100%{opacity:1} }
        @keyframes bounce-in { 0%{transform:scale(0)} 60%{transform:scale(1.2)} 100%{transform:scale(1)} }
        @keyframes wiggle { 0%,100%{transform:rotate(-10deg)} 50%{transform:rotate(10deg)} }
        @keyframes wiggle-reverse { 0%,100%{transform:rotate(10deg)} 50%{transform:rotate(-10deg)} }
        @keyframes float-up { 0%{transform:translateY(100px); opacity:0} 100%{transform:translateY(-100px); opacity:1} }
        @keyframes spin-slow { 0%{transform:rotate(0deg)} 100%{transform:rotate(360deg)} }
        @keyframes bounce { 0%,100%{transform:translateY(0)} 50%{transform:translateY(-15px)} }
        
        .stroke-text {
            -webkit-text-stroke: 2px #d97706; /* Fallback */
        }
        @media (min-width: 768px) {
            .stroke-text { -webkit-text-stroke: 3px #d97706; }
        }
    </style>
</head>
<body class="bg-indigo-50 select-none">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- Icons (Inlined to prevent errors) ---
        const IconHome = ({size=24, className}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>;
        const IconTrophy = ({size=24, className}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/></svg>;
        const IconVolume2 = ({size=24, className}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></svg>;
        const IconVolumeX = ({size=24, className}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><line x1="23" x2="17" y1="9" y2="15"/><line x1="17" x2="23" y1="9" y2="15"/></svg>;
        const IconX = ({size=24}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M18 6 6 18"/><path d="m6 6 18 18"/></svg>;
        const IconMail = ({size=24}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect width="20" height="16" x="2" y="4" rx="2"/><path d="m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7"/></svg>;
        const IconShield = ({size=24}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10"/></svg>;
        const IconHeart = ({size=24}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z"/></svg>;
        const IconBook = ({size=24}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></svg>;
        const IconHelp = ({size=24}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><path d="M12 17h.01"/></svg>;

        // --- Visual Components ---

        const Monster = ({ mood }) => {
            const color = mood === 'happy' ? '#4ade80' : mood === 'sad' ? '#f87171' : '#60a5fa';
            return (
                <div className="relative w-24 h-24 md:w-28 md:h-28 mx-auto transition-transform duration-300 transform hover:scale-105">
                <svg viewBox="0 0 100 100" className="w-full h-full drop-shadow-lg">
                    <rect x="20" y="20" width="60" height="60" rx="15" fill={color} />
                    <circle cx="35" cy="45" r="8" fill="white" />
                    <circle cx="65" cy="45" r="8" fill="white" />
                    <circle cx="35" cy="45" r="3" fill="black" />
                    <circle cx="65" cy="45" r="3" fill="black" />
                    {mood === 'happy' && <path d="M 35 65 Q 50 80 65 65" fill="none" stroke="white" strokeWidth="3" strokeLinecap="round" />}
                    {mood === 'sad' && <path d="M 35 70 Q 50 55 65 70" fill="none" stroke="white" strokeWidth="3" strokeLinecap="round" />}
                    {mood === 'neutral' && <line x1="35" y1="65" x2="65" y2="65" stroke="white" strokeWidth="3" strokeLinecap="round" />}
                    <line x1="50" y1="20" x2="50" y2="5" stroke={color} strokeWidth="4" />
                    <circle cx="50" cy="5" r="5" fill="#fbbf24" />
                </svg>
                </div>
            );
        };

        const Celebration = ({ text }) => (
            <div className="fixed inset-0 z-50 flex items-center justify-center pointer-events-none">
                <div className="absolute inset-0 bg-black/40 backdrop-blur-sm animate-fade-in" />
                <div className="relative flex flex-col items-center animate-bounce-in scale-125 md:scale-150">
                    <div className="absolute -top-16 -left-16 md:-top-20 md:-left-20 text-6xl md:text-8xl animate-wiggle">ðŸŽ‰</div>
                    <div className="absolute -top-16 -right-16 md:-top-20 md:-right-20 text-6xl md:text-8xl animate-wiggle-reverse">âœ¨</div>
                    
                    <div className="text-8xl md:text-9xl filter drop-shadow-2xl animate-spin-slow mb-4">ðŸŒŸ</div>
                    
                    <h2 className="text-5xl md:text-8xl font-black text-transparent bg-clip-text bg-gradient-to-r from-yellow-300 via-orange-400 to-yellow-300 drop-shadow-[0_5px_5px_rgba(0,0,0,0.5)] animate-pulse tracking-wider stroke-text text-center px-4">
                        {text}
                    </h2>

                    <div className="absolute bottom-0 left-[-50px] md:left-[-100px] text-5xl md:text-7xl animate-float-up">ðŸŽˆ</div>
                    <div className="absolute bottom-0 right-[-50px] md:right-[-100px] text-5xl md:text-7xl animate-float-up delay-100">ðŸŽˆ</div>
                </div>
            </div>
        );

        // --- Logic Hooks ---

        const useSound = () => {
            const [isMuted, setIsMuted] = useState(false);
            const audioCtxRef = useRef(null);

            const initAudio = () => {
                if (!audioCtxRef.current) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (AudioContext) audioCtxRef.current = new AudioContext();
                }
                if (audioCtxRef.current?.state === 'suspended') audioCtxRef.current.resume();
            };

            const playSound = (type) => {
                if (isMuted || !audioCtxRef.current) return;
                const ctx = audioCtxRef.current;
                const osc = ctx.createOscillator();
                const gainNode = ctx.createGain();
                osc.connect(gainNode);
                gainNode.connect(ctx.destination);
                const now = ctx.currentTime;

                if (type === 'correct') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(400, now);
                    osc.frequency.exponentialRampToValueAtTime(1200, now + 0.2);
                    gainNode.gain.setValueAtTime(0.3, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.8);
                    
                    const osc2 = ctx.createOscillator();
                    const gain2 = ctx.createGain();
                    osc2.type = 'triangle';
                    osc2.frequency.setValueAtTime(600, now);
                    osc2.frequency.exponentialRampToValueAtTime(1800, now + 0.2);
                    gain2.gain.setValueAtTime(0.1, now);
                    gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
                    osc2.connect(gain2);
                    gain2.connect(ctx.destination);
                    osc2.start(now);
                    osc2.stop(now + 0.6);

                    osc.start(now);
                    osc.stop(now + 0.8);
                } else if (type === 'wrong') {
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.linearRampToValueAtTime(100, now + 0.3);
                    gainNode.gain.setValueAtTime(0.2, now);
                    gainNode.gain.linearRampToValueAtTime(0.01, now + 0.3);
                    osc.start(now);
                    osc.stop(now + 0.3);
                } else if (type === 'pop') {
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(400, now);
                    osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
                    gainNode.gain.setValueAtTime(0.1, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    osc.start(now);
                    osc.stop(now + 0.1);
                } else if (type === 'flip') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(300, now);
                    gainNode.gain.setValueAtTime(0.1, now);
                    gainNode.gain.linearRampToValueAtTime(0.01, now + 0.1);
                    osc.start(now);
                    osc.stop(now + 0.1);
                }
            };
            return { isMuted, setIsMuted, playSound, initAudio };
        };

        // --- Main Game Component ---

        function MathKidsZone() {
            const [screen, setScreen] = useState('menu');
            const [score, setScore] = useState(0);
            const [highScore, setHighScore] = useState(0);
            const [activeModal, setActiveModal] = useState(null);
            
            // Game Data
            const [question, setQuestion] = useState(null);
            const [options, setOptions] = useState([]);
            const [feedback, setFeedback] = useState(null);
            const [praise, setPraise] = useState(''); 
            const [monsterMood, setMonsterMood] = useState('neutral');
            const [memoryCards, setMemoryCards] = useState([]);
            const [flippedIndices, setFlippedIndices] = useState([]);

            const { isMuted, setIsMuted, playSound, initAudio } = useSound();

            const handleInteraction = () => initAudio();

            const getPraise = () => {
                const words = ['Awesome!', 'Superb!', 'Genius!', 'Great Job!', 'Amazing!', 'Brilliant!'];
                return words[Math.floor(Math.random() * words.length)];
            };

            const generateProblem = (type) => {
                const num1 = Math.floor(Math.random() * 10) + 1;
                const num2 = Math.floor(Math.random() * 10) + 1;
                
                if (type === 'subtraction') {
                    let [n1, n2] = num1 < num2 ? [num2, num1] : [num1, num2];
                    return { q: `${n1} - ${n2}`, a: n1 - n2, type: '-' };
                } else if (type === 'operator') {
                    const ops = ['+', '-'];
                    const op = ops[Math.floor(Math.random() * ops.length)];
                    let n1 = num1, n2 = num2, ans;
                    if (op === '+') ans = n1 + n2;
                    else {
                        if (n1 < n2) [n1, n2] = [n2, n1];
                        ans = n1 - n2;
                    }
                    return { num1: n1, num2: n2, ans: ans, op: op };
                } else {
                    return { q: `${num1} + ${num2}`, a: num1 + num2, type: '+' };
                }
            };

            const generateTrain = () => {
                const start = Math.floor(Math.random() * 5) + 1;
                const step = Math.floor(Math.random() * 3) + 1; 
                const missingIndex = Math.floor(Math.random() * 4); 
                
                const train = [];
                for(let i=0; i<4; i++) {
                    train.push(start + (i * step));
                }
                const answer = train[missingIndex];
                train[missingIndex] = '?';
                
                const opts = new Set([answer]);
                while(opts.size < 3) {
                    opts.add(answer + Math.floor(Math.random() * 5) - 2);
                }
                const finalOpts = Array.from(opts).filter(n => n > 0 && n !== answer).slice(0, 2);
                finalOpts.push(answer);
                
                return { sequence: train, answer: answer, options: finalOpts.sort(() => Math.random() - 0.5) };
            };

            const generateCroc = () => {
                const v1 = Math.floor(Math.random() * 20) + 1;
                const v2 = Math.floor(Math.random() * 20) + 1;
                let rel = '=';
                if(v1 > v2) rel = '>';
                if(v1 < v2) rel = '<';
                return { v1, v2, rel };
            };

            const generateMemory = () => {
                const pairs = [];
                for(let i=0; i<3; i++) {
                    const p = generateProblem(Math.random() > 0.5 ? 'addition' : 'subtraction');
                    pairs.push({ id: i*2, content: p.q, val: p.a, type: 'q', matched: false, flipped: false });
                    pairs.push({ id: i*2+1, content: p.a, val: p.a, type: 'a', matched: false, flipped: false });
                }
                return pairs.sort(() => Math.random() - 0.5);
            };

            const startGame = (mode) => {
                handleInteraction();
                playSound('pop');
                setScreen(mode);
                setScore(0);
                setFeedback(null);
                setMonsterMood('neutral');
                nextLevel(mode);
            };

            const nextLevel = (mode) => {
                setFeedback(null);
                setMonsterMood('neutral');
                
                if (mode === 'balloon') {
                    const p = generateProblem(Math.random() > 0.5 ? 'addition' : 'subtraction');
                    setQuestion(p);
                    const opts = new Set([p.a]);
                    while(opts.size < 3) opts.add(p.a + Math.floor(Math.random() * 6) - 3);
                    setOptions(Array.from(opts).filter(n=>n>=0).slice(0,3).sort(() => Math.random() - 0.5));
                } 
                else if (mode === 'monster') {
                    const p = generateProblem('addition');
                    setQuestion(p);
                    const opts = new Set([p.a]);
                    while(opts.size < 3) opts.add(p.a + Math.floor(Math.random() * 5) - 2);
                    setOptions(Array.from(opts).filter(n=>n>=0).slice(0,3).sort(() => Math.random() - 0.5));
                }
                else if (mode === 'sign') {
                    const p = generateProblem('operator');
                    setQuestion(p);
                    setOptions(['+', '-']);
                }
                else if (mode === 'train') {
                    const t = generateTrain();
                    setQuestion(t);
                    setOptions(t.options);
                }
                else if (mode === 'croc') {
                    const c = generateCroc();
                    setQuestion(c);
                    setOptions(['>', '=', '<']);
                }
                else if (mode === 'memory') {
                    setMemoryCards(generateMemory());
                    setFlippedIndices([]);
                }
            };

            const handleStandardAnswer = (ans) => {
                if(feedback) return;
                handleInteraction();
                
                let correct = false;
                if(screen === 'sign') correct = ans === question.op;
                else if(screen === 'train') correct = ans === question.answer;
                else if(screen === 'croc') correct = ans === question.rel;
                else correct = ans === question.a;

                if(correct) {
                    playSound('correct');
                    setScore(s => s + 10);
                    setPraise(getPraise());
                    setFeedback('correct');
                    setMonsterMood('happy');
                    setTimeout(() => nextLevel(screen), 1500); 
                } else {
                    playSound('wrong');
                    setFeedback('wrong');
                    setMonsterMood('sad');
                    setTimeout(() => { setFeedback(null); setMonsterMood('neutral'); }, 800);
                }
            };

            const handleMemoryClick = (idx) => {
                if(flippedIndices.length >= 2 || memoryCards[idx].flipped || memoryCards[idx].matched) return;
                
                handleInteraction();
                playSound('flip');
                
                const newCards = [...memoryCards];
                newCards[idx].flipped = true;
                setMemoryCards(newCards);
                
                const newFlipped = [...flippedIndices, idx];
                setFlippedIndices(newFlipped);
                
                if(newFlipped.length === 2) {
                    const [idx1, idx2] = newFlipped;
                    if(newCards[idx1].val === newCards[idx2].val) {
                        setTimeout(() => {
                            playSound('correct');
                            newCards[idx1].matched = true;
                            newCards[idx2].matched = true;
                            setMemoryCards([...newCards]);
                            setFlippedIndices([]);
                            setScore(s => s + 20);
                            if(newCards.every(c => c.matched)) {
                                setPraise('All M
